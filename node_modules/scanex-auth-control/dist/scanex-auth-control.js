'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var T = _interopDefault(require('scanex-translations'));
var L = _interopDefault(require('leaflet'));

function noop() {}

function run(fn) {
  return fn();
}

function blank_object() {
  return Object.create(null);
}

function run_all(fns) {
  fns.forEach(run);
}

function is_function(thing) {
  return typeof thing === 'function';
}

function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
}

function append(target, node) {
  target.appendChild(node);
}

function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}

function detach(node) {
  node.parentNode.removeChild(node);
}

function element(name) {
  return document.createElement(name);
}

function text(data) {
  return document.createTextNode(data);
}

function space() {
  return text(' ');
}

function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

function stop_propagation(fn) {
  return function (event) {
    event.stopPropagation(); // @ts-ignore

    return fn.call(this, event);
  };
}

function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}

function children(element) {
  return Array.from(element.childNodes);
}

function set_data(text, data) {
  data = '' + data;
  if (text.data !== data) text.data = data;
}

function custom_event(type, detail) {
  const e = document.createEvent('CustomEvent');
  e.initCustomEvent(type, false, false, detail);
  return e;
}

let current_component;

function set_current_component(component) {
  current_component = component;
}

function get_current_component() {
  if (!current_component) throw new Error(`Function called outside component initialization`);
  return current_component;
}

function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}

function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];

    if (callbacks) {
      // TODO are there situations where events could be dispatched
      // in a server (non-DOM) environment?
      const event = custom_event(type, detail);
      callbacks.slice().forEach(fn => {
        fn.call(component, event);
      });
    }
  };
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;

function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}

function add_render_callback(fn) {
  render_callbacks.push(fn);
}

function flush() {
  const seen_callbacks = new Set();

  do {
    // first, call beforeUpdate functions
    // and update components
    while (dirty_components.length) {
      const component = dirty_components.shift();
      set_current_component(component);
      update(component.$$);
    }

    while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call
    // afterUpdate functions. This may cause
    // subsequent updates...


    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];

      if (!seen_callbacks.has(callback)) {
        callback(); // ...so guard against infinite loops

        seen_callbacks.add(callback);
      }
    }

    render_callbacks.length = 0;
  } while (dirty_components.length);

  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }

  update_scheduled = false;
}

function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    $$.fragment && $$.fragment.p($$.ctx, $$.dirty);
    $$.dirty = [-1];
    $$.after_update.forEach(add_render_callback);
  }
}

const outroing = new Set();

function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}

function mount_component(component, target, anchor) {
  const {
    fragment,
    on_mount,
    on_destroy,
    after_update
  } = component.$$;
  fragment && fragment.m(target, anchor); // onMount happens before the initial afterUpdate

  add_render_callback(() => {
    const new_on_destroy = on_mount.map(run).filter(is_function);

    if (on_destroy) {
      on_destroy.push(...new_on_destroy);
    } else {
      // Edge case - component was destroyed immediately,
      // most likely as a result of a binding initialising
      run_all(new_on_destroy);
    }

    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}

function destroy_component(component, detaching) {
  const $$ = component.$$;

  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
    // preserve final state?)

    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}

function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }

  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}

function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const prop_values = options.props || {};
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    before_update: [],
    after_update: [],
    context: new Map(parent_component ? parent_component.$$.context : []),
    // everything else
    callbacks: blank_object(),
    dirty
  };
  let ready = false;
  $$.ctx = instance ? instance(component, prop_values, (i, ret, value = ret) => {
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if ($$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }

    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update); // `false` as a special case of no DOM component

  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

  if (options.target) {
    if (options.hydrate) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      $$.fragment && $$.fragment.l(children(options.target));
    } else {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      $$.fragment && $$.fragment.c();
    }

    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }

  set_current_component(parent_component);
}

class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }

  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }

  $set() {// overridden by instance, if it has props
  }

}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var scanexJsonpRequest_cjs = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  var uniqueGlobalName = function () {
    var freeid = 0;
    return function (thing) {
      var id = "gmx_unique_" + freeid++;
      window[id] = thing;
      return id;
    };
  }();
  /** Посылает кросс-доменный GET запрос к серверу с использованием транспорта JSONP.
   *
   * @memberOf nsGmx.Utils
   * @param {String} url URL сервера.
   * @param {Function} callback Ф-ция, которая будет вызвана при получении от сервера результата.
   * @param {String} [callbackParamName=CallbackName] Имя параметра для задания имени ф-ции ответа.
   * @param {Function} [errorCallback] Ф-ция, которая будет вызвана в случае ошибки запроса к серверу
   */


  function sendCrossDomainJSONRequest(url, callback, callbackParamName, errorCallback) {
    callbackParamName = callbackParamName || 'CallbackName';
    var script = document.createElement("script");
    script.setAttribute("charset", "UTF-8");
    var callbackName = uniqueGlobalName(function (obj) {
      callback && callback(obj);
      window[callbackName] = false;
      document.getElementsByTagName("head").item(0).removeChild(script);
    });
    var sepSym = url.indexOf('?') == -1 ? '?' : '&';

    if (errorCallback) {
      script.onerror = errorCallback;
    }

    script.setAttribute("src", "" + url + sepSym + callbackParamName + "=" + callbackName + "&" + Math.random());
    document.getElementsByTagName("head").item(0).appendChild(script);
  }

  exports.sendCrossDomainJSONRequest = sendCrossDomainJSONRequest;
});
unwrapExports(scanexJsonpRequest_cjs);
var scanexJsonpRequest_cjs_1 = scanexJsonpRequest_cjs.sendCrossDomainJSONRequest;

function parseUri(str) {
  var parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
      key = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
      m = parser.exec(str),
      uri = {},
      i = 14;

  while (i--) uri[key[i]] = m[i] || ""; // HACK


  uri.hostOnly = uri.host;
  uri.host = uri.authority;
  return uri;
}

let requests = {};
let lastRequestId = 0;
let uniquePrefix = `id${Math.random()}`;

function processMessage(e) {
  if (e.origin in requests) {
    let dataStr = decodeURIComponent(e.data.replace(/\n/g, '\n\\'));

    try {
      let dataObj = JSON.parse(dataStr);
      var request = requests[e.origin][dataObj.CallbackName];

      if (request) {
        delete requests[e.origin][dataObj.CallbackName];
        request.iframe.parentNode.removeChild(request.iframe);
        request.callback && request.callback(dataObj);
      }
    } catch (e) {}
  }
} //совместимость с IE8


if (window.addEventListener) {
  window.addEventListener('message', processMessage);
} else {
  window.attachEvent('onmessage', processMessage);
}

function addQueryVariables(url, variables) {
  let oldQueryString = url.split('?')[1];
  let newQueryString = '';

  for (let variable in variables) {
    if (variables.hasOwnProperty(variable)) {
      newQueryString += '&' + variable + '=' + encodeURIComponent(variables[variable]);
    }
  }

  if (oldQueryString) {
    return url + newQueryString;
  } else {
    return url + '?' + newQueryString.slice(1);
  }
}

function createPostIframe(id) {
  var iframe = document.createElement("iframe");
  iframe.style.display = 'none';
  iframe.setAttribute('id', id);
  iframe.setAttribute('name', id);
  iframe.src = 'javascript:true';
  return iframe;
}

class Server {
  constructor({
    root
  }) {
    this._root = root;
  }
  /** Послать GET запрос к серверу ресурсов.
   * @param  {String} url
   * @param  {Object} params
   * @return {Function} promise(data)
   */


  sendGetRequest(url, params) {
    return new Promise((resolve, reject) => {
      let requestUrl = `${this._root}/${url}`;
      requestUrl = addQueryVariables(requestUrl, params);
      scanexJsonpRequest_cjs_1(requestUrl, data => resolve(data), 'CallbackName', errors => reject({
        Status: 'error'
      }));
    });
  }
  /** Послать к серверу ресурсов запрос за картинкой.
   * @param  {String} url
   * @param  {Object} params
   * @return {Function} promise(image)
   */


  sendImageRequest(url, params) {
    let requestUrl = `${this._root}/${url}`;
    requestUrl = addQueryVariables(requestUrl, params);
    var img = new Image();

    img.onload = () => resolve({
      Status: 'ok',
      Result: img
    });

    img.onerror = errors => reject(errors);

    img.src = requestUrl;
  }
  /** Послать POST запрос к серверу ресурсов.
   * @param  {String} url
   * @param  {Object} params
   * @param  {HTMLFormElement} baseForm HTML Form, которая может быть использована как основа для посылки запроса (например, если нужно загрузить файл)
   * @return {Function} promise(data)
   */


  sendPostRequest(url, params, baseForm) {
    let requestURL = `${this._root}/${url}`;
    return new Promise((resolve, reject) => {
      let processResponse = response => {
        if (response.Status !== 'ok') {
          reject(response);
        } else {
          resolve(response);
        }
      };

      try {
        let id = `${uniquePrefix}${lastRequestId++}`;
        let iframe = createPostIframe(id);
        let parsedURL = parseUri(requestURL);
        let origin = (parsedURL.protocol ? `${parsedURL.protocol}:` : window.location.protocol) + `//${parsedURL.host || window.location.host}`;
        let originalFormAction;
        let form;
        requests[origin] = requests[origin] || {};
        requests[origin][id] = {
          callback: processResponse,
          iframe: iframe
        };

        if (baseForm) {
          form = baseForm;
          originalFormAction = form.getAttribute('action');
          form.setAttribute('action', requestURL);
          form.target = id;
        } else {
          form = document.createElement('form');
          form.style.display = 'none';
          form.setAttribute('enctype', 'multipart/form-data');
          form.target = id;
          form.setAttribute('method', 'POST');
          form.setAttribute('action', requestURL);
          form.id = id;
        }

        let hiddenParamsDiv = document.createElement("div");
        hiddenParamsDiv.style.display = 'none';

        let appendFormParam = function (paramName, paramValue) {
          let input = document.createElement("input");
          paramValue = typeof paramValue !== 'undefined' ? paramValue : '';
          input.setAttribute('type', 'hidden');
          input.setAttribute('name', paramName);
          input.setAttribute('value', paramValue);
          hiddenParamsDiv.appendChild(input);
        };

        for (let paramName in params) {
          appendFormParam(paramName, params[paramName]);
        }

        appendFormParam('WrapStyle', 'message');
        appendFormParam('CallbackName', id);
        form.appendChild(hiddenParamsDiv);
        if (!baseForm) document.body.appendChild(form);
        document.body.appendChild(iframe);
        form.submit();

        if (baseForm) {
          form.removeChild(hiddenParamsDiv);
          if (originalFormAction !== null) form.setAttribute('action', originalFormAction);else form.removeAttribute('action');
        } else {
          form.parentNode.removeChild(form);
        }
      } catch (e) {
        reject(e);
      }
    });
  }

}

class ResourceServer extends Server {
  constructor(authManager, {
    id,
    root
  }) {
    super({
      root
    });
    this._id = id;
    this._authManager = authManager;

    this._authManager.$addResourceServer(this);
  }

  sendGetRequest(url, params, baseForm) {
    params = params || {};
    params.sync = this._authManager.$getAntiCsrfToken();
    return new Promise((resolve, reject) => {
      super.sendGetRequest(url, params, baseForm).then(data => {
        data.Service = {
          ServerId: this._id
        };

        if (data.Status === 'ok') {
          resolve(data);
        } else {
          reject(data);
        }
      }).catch(errors => reject({
        Status: 'error',
        ErrorInfo: errors.ErrorInfo
      }));
    });
  }

  sendImageRequest(url, params, baseForm) {
    params = params || {};
    params.sync = this._authManager.$getAntiCsrfToken();
    return new Promise((resolve, reject) => {
      super.sendImageRequest(url, params, baseForm).then(data => {
        data.Service = {
          ServerId: this._id
        };

        if (data.Status === 'ok') {
          resolve(data);
        } else {
          reject(data);
        }
      }).catch(errors => reject({
        Status: 'error',
        ErrorInfo: errors.ErrorInfo
      }));
    });
  }

  sendPostRequest(url, params, baseForm) {
    params = params || {};
    params.sync = this._authManager.$getAntiCsrfToken();
    return new Promise((resolve, reject) => {
      super.sendPostRequest(url, params, baseForm).then(data => {
        data.Service = {
          ServerId: this._id
        };

        if (data.Status === 'ok') {
          resolve(data);
        } else {
          reject(data);
        }
      }).catch(errors => reject({
        Status: 'error',
        ErrorInfo: errors.ErrorInfo
      }));
    });
  }

}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var EventTarget =
/*#__PURE__*/
function () {
  function EventTarget() {
    _classCallCheck(this, EventTarget);

    this.listeners = {};
  }

  _createClass(EventTarget, [{
    key: "addEventListener",
    value: function addEventListener(type, callback) {
      if (!(type in this.listeners)) {
        this.listeners[type] = [];
      }

      this.listeners[type].push(callback);
    }
  }, {
    key: "on",
    value: function on(type, callback) {
      this.addEventListener(type, callback);
      return this;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, callback) {
      if (!(type in this.listeners)) {
        return;
      }

      var stack = this.listeners[type];

      for (var i = 0, l = stack.length; i < l; i++) {
        if (stack[i] === callback) {
          stack.splice(i, 1);
          return this.removeEventListener(type, callback);
        }
      }
    }
  }, {
    key: "off",
    value: function off(type, callback) {
      this.removeEventListener(type, callback);
      return this;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (!(event.type in this.listeners)) {
        return;
      }

      var stack = this.listeners[event.type];
      Object.defineProperty(event, 'target', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: this
      });

      for (var i = 0, l = stack.length; i < l; i++) {
        stack[i].call(this, event);
      }
    }
  }]);

  return EventTarget;
}();

var scanexEventTarget_cjs = EventTarget;

class AuthManager extends scanexEventTarget_cjs {
  constructor({
    authorizationEndpoint,
    userInfoEndpoint,
    redirectEndpointHtml,
    redirectEndpointAshx,
    credentialLoginEndpoint,
    clientId = 1
  }) {
    super(); // поддерживаем как минимум два события для
    // серверов ресурсов: login и logout

    this._authorizationEndpoint = authorizationEndpoint;
    this._userInfoEndpoint = userInfoEndpoint;
    this._redirectEndpointHtml = redirectEndpointHtml;
    this._redirectEndpointAshx = redirectEndpointAshx;
    this._redirectEndpointAshx2 = `${redirectEndpointAshx}/?return_url=${location.href}`;
    this._credentialLoginEndpoint = credentialLoginEndpoint;
    this._resourceServers = [];
    this._clientId = clientId;
  }

  $getAntiCsrfToken() {
    const cookieName = "sync";
    const re = new RegExp(`.*${cookieName}=([^;]+).*`, 'i');
    return document.cookie.replace(re, '$1');
  }
  /** Добавляет сервер ресурсов
   * Должна вызываться только из класса ResourceServer.
   * @param {ResourceServer} resourceServer
   */


  $addResourceServer(resourceServer) {
    this._resourceServers.push(resourceServer);
  }

  _chain(tasks, state) {
    return tasks.reduce((prev, next) => prev.then(next), new Promise((resolve, reject) => resolve(state)));
  }

  _authorizeResourceServers() {
    let tasks = this._resourceServers.map(rs => {
      return state => {
        return new Promise(resolve => {
          rs.sendGetRequest('oAuth2/LoginDialog.ashx').then(response => {
            state = state.concat(response);
            resolve(state);
          }).catch(e => state.push(e));
        });
      };
    });

    return this._chain(tasks, []);
  }

  _processAuthorization(search) {
    function parseQueryString(search) {
      let a = search.slice(1).split('&');
      let o = {};

      for (let i = 0; i < a.length; i++) {
        let s = a[i].split('=');
        o[s[0]] = s[1];
      }

      return o;
    }

    return new Promise((resolve, reject) => {
      // превращаем строку с параметрами в хеш
      let params = parseQueryString(search);

      if (params.error) {
        reject({
          Status: 'auth',
          Result: null,
          Error: {
            message: params.error
          }
        });
      } else {
        scanexJsonpRequest_cjs_1(`${this._redirectEndpointAshx}${search}`, resp => {
          if (resp.Status === 'ok') {
            resolve({
              Status: 'ok',
              Result: resp.Result
            });
          } else {
            reject({
              Status: resp.Status,
              Result: null
            });
          }
        }, 'CallbackName', () => {
          reject({
            Status: 'network',
            Result: null,
            Error: {
              message: arguments[2]
            }
          });
        });
      }
    });
  }
  /** Получение информации о пользователе от AuthServer
   * @return {Function} promise(userInfo)
   */


  getUserInfo() {
    if (this._getUserInfoDeferred) {
      return this._getUserInfoDeferred;
    }

    return this._getUserInfoDeferred = new Promise((resolve, reject) => {
      function authorizationGrant(search) {
        // удаляем айфрейм и глобальную переменную
        setTimeout(function () {
          delete window.authorizationGrant;
          document.body.removeChild(document.body.querySelector('.authorizationIframe'));
        }, 0);

        this._processAuthorization(search).then(resp => resolve(resp), err => reject(err));
      } // посылаем запросы на все сервера ресурсов
      // когда они все ответят ..


      this._authorizeResourceServers().then(servers => {
        // .. формируем параметры state и scope
        let scope = '';
        let state = '';

        for (let i = 0; i < servers.length; i++) {
          let response = servers[i];
          scope += response.Service.ServerId + ',';
          state += response.Result.State + ',';
        }

        scope = scope.slice(0, -1);
        state = state.slice(0, -1); // .. и посылаем запрос на сервер авторизации

        window.authorizationGrant = authorizationGrant.bind(this);
        document.body.insertAdjacentHTML('afterbegin', `<iframe
                    class="authorizationIframe"
                    style="display: block !important; position: absolute; left: -99999px;"
                    src="${this._userInfoEndpoint}/?client_id=1&redirect_uri=${this._redirectEndpointHtml}&scope=${scope}&state=${state}">
                </iframe>`);
      }).catch(() => {
        reject({
          Status: 'error'
        });
      });
    });
  }
  /** Принудительное перелогинивание пользователя.
   * Пользователь должен увидеть поля для ввода
   * логина/пароля (возможно, на сервере авторизации).
   * При успешной авторизации библиотека должна
   * произвести авторизацию пользователя на всех
   * подключенных серверах ресурсов
   * и только после этого resolve promise
   * @return {Function} promise(userInfo)
   */


  login(arg) {
    let foreignServer;
    let iframeContainer;

    if (typeof arg === 'string') {
      // обратная совместимость
      foreignServer = arg;
    } else if (typeof arg === 'object') {
      foreignServer = arg.foreignServer;
      iframeContainer = arg.iframeContainer;
    }

    this._authorizeResourceServers().then(servers => {
      // .. формируем параметры state и scope
      let scope = '';
      let state = '';

      for (let i = 0; i < servers.length; i++) {
        let response = servers[i];
        scope += response.Service.ServerId + ',';
        state += response.Result.State + ',';
      }

      scope = scope.slice(0, -1);
      state = state.slice(0, -1);
      let authUrl = `${this._authorizationEndpoint}/?client_id=1&redirect_uri=${this._redirectEndpointAshx2}&scope=${scope}&state=${state}`;

      if (foreignServer) {
        authUrl += `&authserver=${foreignServer}`;
      }

      if (!iframeContainer) {
        window.open(authUrl, '_self');
      } else {
        window.authorizationGrant = authorizationGrant;
        document.body.removeChild(document.body.querySelector('.authorizationIframe'));
        document.body.insertAdjacentHTML('afterbegin', `<iframe
                    class="authorizationIframe"
                    src="${self._authorizationEndpoint}/?client_id=1
                        &redirect_uri=${self._redirectEndpointHtml}
                        &redirect_uri_alt=${self._redirectEndpointAshx2}
                        &scope=${scope}
                        &state=${state}">
                </iframe>`);

        function authorizationGrant() {
          window.location.reload();
          let event = document.createEvent('Event');
          event.initEvent('login', false, false);
          this.dispatchEvent(event);
        }
      }
    });
  }
  /** Залогиниться, используя логин и пароль
   * @param  {String} login
   * @param  {String} password
   * @return {Promise}
   */


  loginWithCredentials(login, password) {
    // отправляем ajax-запрос на Handler/Login с логином и паролем
    // После этого пользователь считается залогиненным на my.
    // Затем вызываем getUserInfo()
    return new Promise((resolve, reject) => {
      scanexJsonpRequest_cjs_1(`${this._credentialLoginEndpoint}?login=${encodeURIComponent(login)}&password=${encodeURIComponent(password)}`, response => {
        if (response.Status.toLowerCase() === 'ok') {
          this.getUserInfo().then(() => {
            resolve({
              Status: 'ok',
              Result: arguments[0].Result
            });
          }).catch(() => {
            reject({
              Status: 'error',
              Result: {
                Message: 'authorization error'
              }
            });
          });
        } else if (response.Status.toLowerCase() === 'auth') {
          reject({
            Status: 'auth',
            Result: {
              Message: response.Result.Message
            }
          });
        } else {
          reject({
            Status: 'error',
            Result: {
              Message: 'unknown error'
            }
          });
        }
      }, 'CallbackName', () => {
        reject({
          Status: 'network',
          Result: {
            Message: 'network error'
          }
        });
      });
    });
  }
  /** Принудительное разлогинивание пользователя.
   * В том числе и на серверах ресурсов
   * @return {Function} promise(status)
   */


  logout() {
    return new Promise((resolve, reject) => {
      let promises = [];

      for (let i = 0; i < this._resourceServers.length; i++) {
        let resourceServer = this._resourceServers[i];
        let promise = resourceServer.sendGetRequest('oAuth2/Logout.ashx');
        promises.push(promise);
      }

      this._chain(promises, {}).then(() => {
        if (this._clientId === 1) {
          scanexJsonpRequest_cjs_1('//my.kosmosnimki.ru/Handler/Logout', response => resolve({
            Status: 'ok'
          }), '', () => reject({
            Status: 'network'
          }));
        } else {
          resolve({
            Status: 'ok'
          });
          let event = document.createEvent('Event');
          event.initEvent('logout', false, false);
          this.dispatchEvent(event);
        }
      }).catch(() => {
        reject({
          Status: 'error'
        });
      });
    });
  }

}

let resourceServersInstances = {};
let resourceServersConstructors = {};
let authManager; // строка, в которой перечислены псевдонимы используемых нами серверов ресурсов.

resourceServersConstructors['subscriptions'] = () => {
  return new ResourceServer(authManager, {
    id: 'subscriptions',
    root: '//fires.kosmosnimki.ru/SAPIv2'
  });
};

resourceServersConstructors['geomixer2'] = () => {
  return new ResourceServer(authManager, {
    id: 'geomixer2',
    root: '//maps2.kosmosnimki.ru'
  });
};

resourceServersConstructors['geomixer'] = () => {
  return new ResourceServer(authManager, {
    id: 'geomixer',
    root: '//maps.kosmosnimki.ru'
  });
};

resourceServersConstructors['geocode'] = () => {
  return new ResourceServer(authManager, {
    id: 'geocode',
    root: '//geocode.kosmosnimki.ru'
  });
};

function getResourceServer(id) {
  if (!authManager) {
    authManager = getAuthManager();
  } // используем lazy instantiation для отложенного создания
  // необходимых нам компонентов


  if (!resourceServersInstances[id]) {
    resourceServersInstances[id] = resourceServersConstructors[id]();
  }

  return resourceServersInstances[id];
}

function getAuthManager() {
  // то же и с authManager
  if (!authManager) {
    authManager = new AuthManager({
      authorizationEndpoint: '//my.kosmosnimki.ru/Test/LoginDialog',
      userInfoEndpoint: '//my.kosmosnimki.ru/oAuth/LoginDialog',
      redirectEndpointHtml: location.href.replace(/[^\/]+$/, '') + 'oAuth2/oAuthCallback.htm',
      redirectEndpointAshx: location.href.replace(/[^\/]+$/, '') + 'oAuth2/oAuthCallback.ashx',
      credentialLoginEndpoint: '//my.kosmosnimki.ru/Handler/Login'
    });
  }

  return authManager;
}

/* src\AuthWidget.svelte generated by Svelte v3.16.0 */

function create_else_block(ctx) {
	let i;
	let i_title_value;
	let dispose;

	return {
		c() {
			i = element("i");
			attr(i, "class", "icon login");
			attr(i, "title", i_title_value = T.getText("auth.login"));
			dispose = listen(i, "click", stop_propagation(/*login*/ ctx[1]));
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(i);
			dispose();
		}
	};
}

// (63:4) {#if authenticated}
function create_if_block(ctx) {
	let span;
	let t0_value = /*user*/ ctx[0].Nickname + "";
	let t0;
	let t1;
	let i;
	let i_title_value;
	let dispose;

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			i = element("i");
			attr(span, "class", "name");
			attr(i, "class", "icon logout");
			attr(i, "title", i_title_value = T.getText("auth.logout"));
			dispose = listen(i, "click", stop_propagation(/*logout*/ ctx[2]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			insert(target, t1, anchor);
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*user*/ 1 && t0_value !== (t0_value = /*user*/ ctx[0].Nickname + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t1);
			if (detaching) detach(i);
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*authenticated*/ ctx[3]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "auth-widget");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	T.addText("rus", {
		auth: { "login": "Войти", "logout": "Выйти" }
	});

	T.addText("eng", {
		auth: { "login": "Login", "logout": "Logout" }
	});

	let authenticated = false;
	let { user } = $$props;
	const authManager = getAuthManager();
	const rsGmx = getResourceServer("geomixer");
	const dispatch = createEventDispatcher();

	onMount(() => {
		authManager.getUserInfo().then(response => {
			$$invalidate(3, authenticated = true);
			$$invalidate(0, user = response.Result);
			const sync = authManager.$getAntiCsrfToken();
			dispatch("login", sync);
		}).catch(response => {
			$$invalidate(3, authenticated = false);
			dispatch("denied");
		});
	});

	function login() {
		authManager.login();
	}

	function logout() {
		authManager.logout().then(() => {
			$$invalidate(3, authenticated = false);
			$$invalidate(0, user = null);
			window.location.reload();
			dispatch("logout");
		});
	}

	$$self.$set = $$props => {
		if ("user" in $$props) $$invalidate(0, user = $$props.user);
	};

	return [user, login, logout, authenticated];
}

class AuthWidget extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { user: 0, login: 1, logout: 2 });
	}

	get login() {
		return this.$$.ctx[1];
	}

	get logout() {
		return this.$$.ctx[2];
	}
}

let authWidget;
let AuthControl = L.Control.extend({
  includes: L.Evented.prototype,
  onAdd: function (map) {
    let container = L.DomUtil.create('div');
    authWidget = new AuthWidget({
      target: container
    });
    authWidget.$on('login', ({
      detail
    }) => {
      this.fire('login', {
        sync: detail
      });
    });
    authWidget.$on('logout', () => {
      this.fire('logout');
    });
    authWidget.$on('denied', () => this.fire('denied'));
    return container;
  },
  onRemove: function (map) {
    if (authWidget) {
      authWidget.$destroy();
    }
  },
  login: function () {
    if (authWidget) {
      authWidget.login();
    }
  },
  logout: function () {
    if (authWidget) {
      authWidget.logout();
    }
  }
});

const authControl = function (opts) {
  return new AuthControl(opts);
};

exports.AuthControl = AuthControl;
exports.AuthWidget = AuthWidget;
exports.authControl = authControl;
//# sourceMappingURL=scanex-auth-control.js.map
